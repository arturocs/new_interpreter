use crate::Expression;
use crate::Variant;
grammar;

// coma

// asignacion

// and, or

// igual, distinto

// menor, mayor 


pub Expression: Expression = { // (1)
    <e:Expression> "+" <f:Factor> => Expression::Add(Box::new((e,f))), // (2)
    <e:Expression> "-" <f:Factor> => Expression::Sub(Box::new((e,f))), // (2)
    Factor,
};


Factor: Expression = {
    <f:Factor> "*" <t:AAA> => Expression::Mul(Box::new((f,t))),
    <f:Factor> "/" <t:AAA> => Expression::Div(Box::new((f,t))),
    <f:Factor> "%" <t:AAA> => Expression::Rem(Box::new((f,t))),
    AAA,
};



// logical not,  -



// index, fn call, list, dict

//block


// Block: Expression = {
//     "{" <e:Expression> "}" => e,
//     "{" <e:Expression> ";" <e2:Expression> "}" => Expression::Block(Box::new((e,e2))),
//     "{" <e:Expression> ";" <e2:Expression> ";" <e3:Expression> "}" => Expression::Block(Box::new((e,e2,e3))),

// }

AAA : Expression = {
    Dict => Expression::Dictionary(<>),
    Term
}

Term: Expression = {
    Int => Expression::Value(Variant::int(<>)),
    Float => Expression::Value(Variant::float(<>)),
    Str => Expression::Value(Variant::str(<>)),
    Identifier => Expression::Identifier(String::from(<>)),
    Block => Expression::Block(<>),
   
    
    "(" <Expression> ")"
};


Block: Vec<Expression> = { // (0)
    "{" <mut v:(<Expression> ";")*> <e:Expression?> "}" => match e { // (1)
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Dict : Vec<(Expression,Expression)> = {
    "{" <mut v:(<Expression> ":" <Expression>",")*> <e:(<Expression> ":" <Expression>)?> "}" => match e { // (1)
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


Identifier : &'input str = {
    r"[a-zA-Z_$][a-zA-Z_$0-9]*" => <>,
}

Int: i128 = {
    r"[+-]?[0-9]+" => <>.parse().unwrap()
};

Float : f64 = {
    r"[+-]?([0-9]+([.][0-9]*)|[.][0-9]+)" => <>.parse().unwrap()
};

Str : &'input str = {
    r#""(?:\\.|[^"\\])*""# => &<>[1..<>.len()-1]
}